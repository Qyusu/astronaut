from astronaut.logics.common.validation import is_same_code


def test_is_same_code() -> None:
    generated_code = 'import numpy as np\nimport pennylane as qml\nfrom qxmt.constants import PENNYLANE_PLATFORM\nfrom qxmt.feature_maps import BaseFeatureMap\n\nclass MNISTFeatureMap(BaseFeatureMap):\n    """MNIST feature map class using DCT and amplitude encoding.\n\n    Args:\n        BaseFeatureMap (_type_): base feature map class\n\n    Example:\n        >>> import numpy as np\n        >>> from qxmt.feature_maps.pennylane.mnist import MNISTFeatureMap\n        >>> feature_map = MNISTFeatureMap(10)\n        >>> feature_map.draw(x_dim=784)\n    """\n\n    def __init__(self, n_qubits: int) -> None:\n        """Initialize the MNIST feature map class.\n\n        Args:\n            n_qubits (int): number of qubits\n        """\n        super().__init__(PENNYLANE_PLATFORM, n_qubits)\n        self.n_qubits: int = n_qubits\n\n    def feature_map(self, x: np.ndarray) -> None:\n        """Create quantum circuit of MNIST feature map.\n\n        Args:\n            x (np.ndarray): input data, expected to be a 1D array of length 784\n        """\n        # Step 1: Apply Discrete Cosine Transform (DCT) to reduce dimensionality\n        from scipy.fftpack import dct\n        x_dct = dct(x, norm=\'ortho\')[:self.n_qubits]\n\n        # Step 2: Normalize the reduced data for amplitude encoding\n        norm = np.linalg.norm(x_dct)\n        if norm == 0:\n            raise ValueError("Input data norm is zero, cannot normalize.")\n        x_normalized = x_dct / norm\n\n        # Step 3: Encode the normalized data into quantum states\n        padded_length = 2 ** int(np.ceil(np.log2(self.n_qubits)))\n        x_padded = np.pad(x_normalized, (0, padded_length - len(x_normalized)), \'constant\')\n        qml.AmplitudeEmbedding(features=x_padded, wires=range(self.n_qubits), normalize=False)\n\n        # Step 4: Add structured entanglement\n        for i in range(self.n_qubits - 1):\n            qml.CNOT(wires=[i, i + 1])'  # noqa

    same_code = 'import numpy as np\nimport pennylane as qml\nfrom qxmt.constants import PENNYLANE_PLATFORM\nfrom qxmt.feature_maps import BaseFeatureMap\n\nclass MNISTFeatureMap(BaseFeatureMap):\n    """MNIST feature map class using DCT and amplitude encoding.\n\n    Args:\n        BaseFeatureMap (_type_): base feature map class\n\n    Example:\n        >>> import numpy as np\n        >>> from qxmt.feature_maps.pennylane.mnist import MNISTFeatureMap\n        >>> feature_map = MNISTFeatureMap(10)\n        >>> feature_map.draw(x_dim=784)\n    """\n\n    def __init__(self, n_qubits: int) -> None:\n        """Initialize the MNIST feature map class.\n\n        Args:\n            n_qubits (int): number of qubits\n        """\n        super().__init__(PENNYLANE_PLATFORM, n_qubits)\n        self.n_qubits: int = n_qubits\n\n    def feature_map(self, x: np.ndarray) -> None:\n        """Create quantum circuit of MNIST feature map.\n\n        Args:\n            x (np.ndarray): input data, expected to be a 1D array of length 784\n        """\n        # Step 1: Apply Discrete Cosine Transform (DCT) to reduce dimensionality\n        from scipy.fftpack import dct\n        x_dct = dct(x, norm=\'ortho\')[:self.n_qubits]\n\n        # Step 2: Normalize the reduced data for amplitude encoding\n        norm = np.linalg.norm(x_dct)\n        if norm == 0:\n            raise ValueError("Input data norm is zero, cannot normalize.")\n        x_normalized = x_dct / norm\n\n        # Step 3: Encode the normalized data into quantum states\n        padded_length = 2 ** int(np.ceil(np.log2(self.n_qubits)))\n        x_padded = np.pad(x_normalized, (0, padded_length - len(x_normalized)), \'constant\')\n        qml.AmplitudeEmbedding(features=x_padded, wires=range(self.n_qubits), normalize=False)\n\n        # Step 4: Add structured entanglement\n        for i in range(self.n_qubits - 1):\n            qml.CNOT(wires=[i, i + 1])'  # noqa

    different_code = 'import numpy as np\nimport pennylane as qml\nfrom qxmt.constants import PENNYLANE_PLATFORM\nfrom qxmt.feature_maps import BaseFeatureMap\n\nclass MNISTFeatureMap(BaseFeatureMap):\n    """MNIST feature map class using DCT and amplitude encoding.\n\n    Args:\n        BaseFeatureMap (_type_): base feature map class\n\n    Example:\n        >>> import numpy as np\n        >>> from qxmt.feature_maps.pennylane.mnist import MNISTFeatureMap\n        >>> feature_map = MNISTFeatureMap(10)\n        >>> feature_map.draw(x_dim=784)\n    """\n\n    def __init__(self, n_qubits: int) -> None:\n        """Initialize the MNIST feature map class.\n\n        Args:\n            n_qubits (int): number of qubits\n        """\n        super().__init__(PENNYLANE_PLATFORM, n_qubits)\n        self.n_qubits: int = n_qubits\n\n    def feature_map(self, x: np.ndarray) -> None:\n        """Create quantum circuit of MNIST feature map.\n\n        Args:\n            x (np.ndarray): input data, expected to be a 1D array of length 784\n        """\n        # Step 1: Apply Discrete Cosine Transform (DCT) to reduce dimensionality\n        from scipy.fftpack import dct\n        x_dct = dct(x, norm=\'ortho\')[:self.n_qubits]\n\n'  # noqa

    assert is_same_code(generated_code, same_code)
    assert not is_same_code(generated_code, different_code)
